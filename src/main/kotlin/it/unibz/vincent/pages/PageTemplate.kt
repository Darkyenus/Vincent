package it.unibz.vincent.pages

import io.undertow.server.HttpServerExchange
import io.undertow.util.AttachmentKey
import it.unibz.vincent.CSRF_FORM_TOKEN_NAME
import it.unibz.vincent.Session
import it.unibz.vincent.util.LocaleStack
import it.unibz.vincent.util.ROUTE_ACTION_PARAM_NAME
import it.unibz.vincent.util.languages
import it.unibz.vincent.util.sendHtml
import kotlinx.html.BODY
import kotlinx.html.BUTTON
import kotlinx.html.ButtonType
import kotlinx.html.FORM
import kotlinx.html.FlowContent
import kotlinx.html.FormEncType
import kotlinx.html.FormMethod
import kotlinx.html.HTML
import kotlinx.html.body
import kotlinx.html.button
import kotlinx.html.div
import kotlinx.html.form
import kotlinx.html.head
import kotlinx.html.hiddenInput
import kotlinx.html.lang
import kotlinx.html.li
import kotlinx.html.link
import kotlinx.html.meta
import kotlinx.html.title
import kotlinx.html.ul

/** Build head and body. */
fun HTML.base(lang:String = "en", title:String = "Vincent", description:String = "", createBody: BODY.() -> Unit) {
	this.lang = lang
	head {
		meta(charset = "UTF-8")
		title(title)
		if (description.isNotBlank()) {
			meta(name="description", content=description)
		}
		meta("viewport", "width=device-width, initial-scale=1")

		link("https://fonts.googleapis.com/css?family=Merriweather:400,700&display=swap&subset=latin-ext", rel="stylesheet", type="text/css") {
			attributes["referrerpolicy"] = "no-referrer"
		}
		link("css/normalize.css", rel="stylesheet")
		link("css/skeleton.css", rel="stylesheet")

		// Current favicon generated by https://realfavicongenerator.net
		// from https://www.icofont.com (glass)

		comment("Generated by realfavicongenerator.net, icon under MIT license from www.icofont.com")
		link(rel="apple-touch-icon", href="/apple-touch-icon.png") { sizes = "180x180" }
		link(rel="icon", type="image/png", href="/favicon-32x32.png") { sizes = "32x32" }
		link(rel="icon", type="image/png", href="/favicon-16x16.png") { sizes = "16x16" }
		link(rel="manifest", href="/site.webmanifest")
		link(rel="mask-icon", href="/safari-pinned-tab.svg") { attributes["color"] ="#b00b10" }
		meta(name="msapplication-TileColor", content="#b91d47")
		meta(name="theme-color", content="#ffffff")
	}

	body {
		createBody.invoke(this)
	}
}

/** Include necessary extra data into the form (anti-CSRF token). */
fun FORM.session(session: Session) {
	hiddenInput(name = CSRF_FORM_TOKEN_NAME) { value = session.csrfToken }
}

fun FORM.routeAction(routeAction:String?) {
	if (routeAction != null) {
		hiddenInput(name= ROUTE_ACTION_PARAM_NAME) { value = routeAction }
	}
}

fun FlowContent.getButton(url:String, vararg extraParams:Pair<String, String>, routeAction:String? = null, classes:String? = null, block : BUTTON.() -> Unit) {
	form(url, method=FormMethod.get) {
		button(type= ButtonType.submit, classes=classes){ block() }
		routeAction(routeAction)
		for ((k, v) in extraParams) {
			hiddenInput(name= k) { value = v }
		}
	}
}

fun FlowContent.postButton(session:Session, url:String, vararg extraParams:Pair<String, String>, routeAction:String? = null, classes:String? = null, block : BUTTON.() -> Unit) {
	form(url, method=FormMethod.post) {
		button(type= ButtonType.submit, classes=classes){ block() }
		routeAction(routeAction)
		session(session)
		for ((k, v) in extraParams) {
			hiddenInput(name= k) { value = v }
		}
	}
}

fun HttpServerExchange.sendBase(title:String = "", createBody: BODY.(HttpServerExchange, LocaleStack) -> Unit) {
	val languages = languages()
	// TODO(jp): Localize!
	sendHtml {
		base("en", title, "Wine evaluation questionnaires") {
			createBody(this@sendBase, languages)
		}
	}
}

private class Messages {
	var warningMessages:ArrayList<String>? = null
	var infoMessages:ArrayList<String>? = null
}

private val messageAttachment = AttachmentKey.create(Messages::class.java)

fun HttpServerExchange.messageWarning(text:String?) {
	text ?: return
	val messages = getAttachment(messageAttachment) ?: Messages().also {
		putAttachment(messageAttachment, it)
	}
	val list = messages.warningMessages ?: ArrayList<String>().also {
		messages.warningMessages = it
	}
	list.add(text)
}

fun HttpServerExchange.messageWarningCount():Int {
	val messages = getAttachment(messageAttachment) ?: return 0
	val list = messages.warningMessages ?: return 0
	return list.size
}

fun HttpServerExchange.messageInfo(text:String?) {
	text ?: return
	val messages = getAttachment(messageAttachment) ?: Messages().also {
		putAttachment(messageAttachment, it)
	}
	val list = messages.infoMessages ?: ArrayList<String>().also {
		messages.infoMessages = it
	}
	list.add(text)
}

fun FlowContent.renderMessages(exchange:HttpServerExchange) {
	val messages = exchange.getAttachment(messageAttachment) ?: return

	messages.warningMessages?.let {
		if (it.isNotEmpty()) {
			div("row warning box") {
				if (it.size == 1) {
					+it[0]
				} else {
					ul {
						for (message in it) {
							li { +message }
						}
					}
				}
			}
		}
	}

	messages.infoMessages?.let {
		if (it.isNotEmpty()) {
			div("row info box") {
				if (it.size == 1) {
					+it[0]
				} else {
					ul {
						for (message in it) {
							li { +message }
						}
					}
				}
			}
		}
	}
}